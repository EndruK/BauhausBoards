\chapter{BauhausBoards}\label{BauhausBoards}
Das neue Projekt bekam den Namen ``BauhausBoards''.
In einer Entwurfsphase entschied ich, wie das System aussehen und welche Funktionen es bieten sollte. Dabei flossen die Ergebnisse der Vorstudie und anderer Projekte mit ein.
\\
Als Voraussetzung sollten als Anzeigegeräte für die Türschilder weiterhin Tablets genutzt werden.
Der Entwurf wurde darauf in ein Programm umgesetzt, wobei manche geplante Funktionen geändert, entfernt oder neue hinzugefügt wurden. An manchen Stellen der Umsetzung kam es auch zu Problemen, die es zu lösen galt.
% - Ergebnisse der Vorstudie sollten enbezogen werden
% - sollte weiterhin auf Tablets als Anzeigegerät laufen
% - das was im Entwurf geplant wurde musste umgesetzt werden
% - dadurch entstanden Features
% - Während der Umsetzung traten diverse Probleme auf










\section{Entwurf}\label{Entwurf}
\subsection{Systementwurf}\label{Systementwurf}
Die Planung des Systems begann damit, die Plattform des Systems auszuwählen. Es gab die Möglichkeit eine Android-Applikation zu erstellen, die auf jedem Tablet installiert werden müsste. Dabei gäb es jedoch das Problem, dass die Nutzer auch von unterwegs mit der Anwendung interagieren sollten, wofür ein eigenständiger Server für die Datenverwaltung notwendig gewesen wäre. Außerdem müsste durch die unterschiedlichen Tablet- und Smartphone-Betriebssysteme neben Android, wie Apple IOS oder Windows Mobile, die App für jede Architektur portiert werden.
\\
Deswegen fiel die Wahl auf eine Web-Applikation. Zum Einen, weil jedes Tablet, jedes Smartphone und jeder PC Webseiten darstellen kann und es nicht nötig ist, extra eine App auf den Geräten zu installieren.
\\ \todotext{darauf eingehen, dass NetBoards auch eine Web-Applikation benutzt hat?}\\
%Zudem setzte das NetBoards Projekt ebenfalls auf eine Web-Applikation
Ein zentraler Webserver generiert eine Webseite mit allen nötigen Frontend Funktionen, die von allen Geräten mit Web-Browser (Clients) angezeigt werden kann. Dadurch sollte sich der Programmieraufwand auf Server- und Client-Funktionen einschränken.
\\
Die Applikation sollte nicht bei jeder kleinsten Interaktion mit der Webseite diese neu laden müssen. Das hätte einen viel zu großen Overhead erzeugt, da bei jeder Kommunikation statische Daten übertragen worden wären.
Deswegen musste der Server nur beim ersten Aufruf das Grundgerüst der Webseite mit allen Client-Funktionen ausliefern. Ein Teil der Funktionen würde dann Daten nachladen oder an den Server schicken, wodurch ein dynamischer Inhalt erzeugt wird.
Dies sollte mit dem ``CRUD'' (Create, Read, Update and Delete) Prinzip realisiert werden.
Der Server wartet, nachdem er eine Seite ausgeliefert hat, auf spezifische Anfragen des Clients und liefert dementsprechend Daten aus (Read) oder ändert den Zustand der Daten (Create, Update und Delete). Zudem gewährleistet dieses Prinzip, dass bei Verbindungsabbrüchen die Seite auf dem Client weiter läuft und nur so lange keine Daten ändern oder nachladen kann, bis die Verbindung wieder aufgebaut wurde.
\\
Die anfallenden Daten des Systems mussten in irgend einer Form auf dem Server gespeichert werden. Die beste Methode dafür war die Nutzung einer Datenbank. Anders als bei NetBoards, wo alle Daten als JSON-Dateien auf dem Server gespeichert wurden, sah ich diese Methode als geeigneter an. Mit einer Datenbank war es möglich Relationen besser darzustellen, Konsistenz zu bewahren und Redundanz zu vermeiden. Zudem sind damit Daten zentralisiert zusammengefasst, wodurch eine bessere Suche nach bestimmten Daten möglich ist.
\\
Die Wahl des Datenbanksystems fiel auf ``SQLite''\cite{sqlite:website}, da es das am meisten verbreitete relationale Datenbanksystem der Welt ist. Es war einfach zu benutzen und hatte eine gute Dokumentation.
\\
Das Gerüst der Webseite sollte auf HTML basieren, wobei die hauptsächlichen Client-Funktionen üblicherweise in Javascript umgesetzt werden. Da die Clients viele Funktionen bieten sollten und der Server nur zum Ausliefern der Webseite und für den Datenaustausch dienen sollte, machte es Sinn für den Server ``Node.js'' zu verwenden. \quelle{Node.js ist serverseitiges Javascript basierend auf Google Chrome's V8 Javascript Engine}{nodejs:website}.
\\
\\
In der Abb. \ref{img:Systemaufbau} ist der Aufbau des Systems zusammengefasst. Auf dem Server befinden sich der Webserver und die Datenbank. Der Webserver stellt Anfragen an die Datenbank und erhält dafür entsprechende Ergebnisse zurückgeliefert.
\\
Wenn ein Client die Adresse des Servers aufruft generiert der Webserver die Webseite und sendet sie mit allen benötigten Funktionen an den Client. Solange die Seite nicht explizit neu geladen werden soll, kommuniziert der Client danach nur durch CRUD Interaktionen mit dem Server.
\\
\begin{figure}[h!]
  \centering
    \includegraphics[width=0.8\textwidth]{./img/Systemaufbau.png}
  \caption{Bauhausboards - Systemaufbau}
  \label{img:Systemaufbau}
\end{figure}
\\
Da die Nutzer die Möglichkeit bekommen sollten, individuellen Inhalt präsentieren zu können, musste ein geeigneter Editor programmiert werden.
Damit sollte es möglich sein, einfache Zeichnungen anzufertigen, Texte zu schreiben oder Bilder hochladen zu können.
Es war wichtig, dass der Editor die Funktionen eines Whiteboards in manchen Zügen übernehmen oder möglicherweise sogar verbessern konnte.
\\
Folgende Whiteboard-Funktionen musste der Editor daher abbilden:
\begin{itemize}
  \item Zeichnen mit verschiedenfarbigen Stiften
  \item Entfernen von Zeichnungen mit einem Schwamm
  \item Anbringung von Bildern oder Ausdrücken per Magnet
  \item Neuanordnung von aufgehängten Elementen
\end{itemize}
Als Grundlage für den Editor entschied ich mich für die Javascript Bibliothek ``Paper.js''\cite{paperjs:website}.
Es ist ein Open Source Framework für die Darstellung und Manipulation von Vektorgrafiken, welches auch die Grundlage des Editors aus dem NetBoards Projekt bildete\cite{wood:2014}.
\\
\\
Eine weitere wichtige Entscheidung war, dass nur die an den Boards registrierten Nutzer den dargestellten Inhalt ändern können sollten, da sich in der Vorstudie herausstellte, dass durch die Anonymität der Besucher es häufig zu unerwünschten Änderungen kam.
Dadurch sollte ein weiterer Sicherheitsaspekt geschaffen werden, da keine andere Person die Daten ändern kann außer derjenige, der sie erstellt hat.
\\
Den Besuchern sollte jedoch weiterhin die Möglichkeit geboten werden mit den registrierten Nutzern in Kontakt treten zu können. Dies konnte mit einer separaten Nachrichtenfunktion realisiert werden.











\subsection{Interface-Entwurf}\label{Interface-Entwurf}
\subsubsection{Hauptansicht}\label{Hauptansicht}
Da den Gästen in der Vorstudie nicht bewusst war, dass mehrere Personen auf dem Board registriert waren, was der Größe des Tablets zu verschulden war, musste der vorhandene Platz anders aufgeteilt werden. Das NetBoards System teilte den Bereich verschiedener Benutzer räumlich, indem es den verfügbaren Platz durch die Anzahl der registrierten Benutzer teilte.
Auf einem 10,1 Zoll großem Tablet macht dieser Ansatz jedoch wenig Sinn, da bei mehr als einem Benutzer der verfügbare Platz zu klein wäre\abb{img:aufteilungMainView}.
Deswegen sollte jeder registrierte Nutzer die ganze Fläche zu Verfügung haben, wobei nach einer festgelegten Zeit die Sicht wechselt und die Daten des nächsten Nutzers anzeigt.\\
\begin{figure}[h!]
  \centering
    \includegraphics[width=0.68\textwidth]{./img/AufteilungMainView.png}
  \caption{Vergleich der Platzverteilung NetBoards - Bauhausboards}
  \label{img:aufteilungMainView}
\end{figure}
\\
Die Datenansicht sollte in zwei Schichten aufgeteilt werden. Zum einen eine Editor-Schicht für selbst gezeichnete Skizzen, Texte, Bilder und animierte Gifs, sowie eine Hintergrundschicht, in der die Nutzer eine Webseite anzeigen lassen können. Da NetBoards diese Funktion bereits bot und die Testnutzer in der Vorstudie diese ebenfalls nutzten entschied ich mich sie ebenfalls umzusetzen.
\\
Um auf der Webseite navigieren zu können musste es dafür ein Menü geben, die auf den Tablets nicht viel Platz wegnahm. Die beste Variante dafür war ein Sidebar, der standardmäßig eingeklappt war und sich per Klick oder Swipe-Geste öffnen ließ.
In diesem Menü sollten alle Navigationselemente zu untergebracht sein. 
\\
Um Informationen über die Nutzer anzeigen zu können wurde eine zusätzliche Fläche benötigt. Dafür sollte im oberen Bereich des Displays ein Teil nur für solche Informationen reserviert sein. In diesem Header konnte man das Profilbild, den Namen und eine Beschreibung des aktuell ausgewählten Nutzers darstellen.
In der Vorstudie wurde es sehr gut aufgenommen, dass einer der Nutzer seinen aktuellen Status angegeben hat. Deswegen sollte diese Funktion neben den Nutzerinformationen im Header zu finden sein.
\begin{figure}[h!]
  \centering
    \includegraphics[width=0.7\textwidth]{./img/MainViewAufbau.png}
  \caption{Aufbau der Hauptansicht}
  \label{img:mainView}
\end{figure}
\\
%Messages
Damit die Gäste mit den Besitzern in Kontakt treten können musste es eine Nachrichtenfunktion geben. Dabei sollten die Benutzer, die eine Nachricht erstellen wollen, einen oder mehrere Besitzer auswählen können. Wenn sie das getan haben, soll der Editor aktiviert werden und die Besucher können eine Zeichnung oder einen Text zeichnen. Die Besitzer müssen, nachdem die Nachricht abgeschickt wurde, darüber informiert werden, dass jemand ihnen etwas geschrieben hat.
% - QR-Code, um mit Smartphone einzuscannen -> möglichkeit per smartphone Nachrichten zu hinterlassen
%\\
%Feedback
%Um Feedback sammeln zu können, sollten die Besucher noch gesonderte Nachrichten
% - Nutzer die Vorbei gehen sollen in irgend einer weise Feedback senden können (in Vorstudie hat sich gezeigt, dass niemand auf die daneben aufgehangenen Zettel etwas schreiben wollte - deshalb direktes Feedback per app)

\subsubsection{Benutzer-Backend}\label{Nutzer-Backend}
Die Besitzer der Boards sollen ihre angezeigten Daten ändern, einen Status setzten und empfangene Nachrichten lesen können.
Damit sie diese Funktionen nutzen können, müssen sie sich vorher im Benutzer-Backend authentisieren.
Zusätzlich soll das Backend den Nutzern die Möglichkeit bieten ihre Nutzerdaten, wie das Profilbild, die Benutzerbeschreibung oder das Passwort zu ändern.\\
Mit einer ``Inhalt ändern'' Funktion können die Besitzer ihre angezeigten Daten der Hauptseite ändern. Dafür wird der selbe Editor benutzt, der auch bei der Erstellung von Besuchernachrichten zum Einsatz kommt. Zusammenhängend mit der Änderung in der Editor-Schicht müssen die Nutzer auch die Hintergrund-Schicht ändern.\\


% Übernahme aus meinem Entwurf:  (User Backend)
% - Set Status kann einen Text setzen, der so lange angezeigt wird, wie der Nutzer es will
% - Sie sollen einen Status setzen können, um vorbeigehende Nutzer darüber zu Informieren, was sie jetzt zur Zeit machen, ob sie grade im Büro sind, nur kurz essen, den halben oder ganzen Tag nicht da sind oder im Labor anzutreffen sind
% - Um schnell einen Status zu setzen, quasi wenn man schnell weg muss und an seinem Board vorbei geht, soll zum Authentisieren des Nutzers ein 4 Stelliger PIN genutzt werden. Der Nutzer soll angeben, welcher der registrierten Nutzern des Raumes er ist und dazu seinen PIN eingeben. Wenn er das getan hat kann er einen Status setzen oder sich als Verfügbar/Nicht Verfügbar kennzeichnen
% - Nutzer müssen Möglichkeit bekommen Nachrichten einzusehen
% - Ungelesene Nachrichten sollen gehighlighted werden
% - Nutzer im Raum sollen zudem Ihre ganzen Daten ändern können (Name, Beschreibung, Mail, ProfilePic, PAsswort, PIN, ...) Dazu ist aber das Passwort des Nutzers erforderlich














\subsubsection{Administrator-Backend}\label{Administrator-Backend}
% Übernahme aus meinem Entwurf:  (Admin Backend)
% - Nur für Nutzer mit Adminstatus zugänglich
% - Statistics
% - Add, Change, Remove Users, Rooms, Boards
% - 'sind sie sicher' prompts
% - Logs, um sich den Inhalt des Raumes anzusehen
% - Administrator der Applikation muss die Möglichkeit haben neue Nutzer, neue Räume und neue Boards zu erstellen und initialisieren
% - Zu Studienzwecken muss der Administrator zudem in der Lage sein alle Nachrichten und erstellte COntents auswerten zu können



% Bild der Seitennavigation
% vllt zu jeder View noch ein Beispielbild?




% - erster Entwurf der Seitenstruktur als Bild
% - Sidebar zum Navigieren


\subsection{Datenbankentwurf}\label{Datenbankentwurf}
% \begin{figure}[h!]
%   \centering
%     \includegraphics[width=1\textwidth]{./img/ER01.png}
%   \caption{Bauhausboards - Datenbankentwurf}
%   \label{img:ER01}
% \end{figure}
% 
%Aufbau der Datenbank
%SQLITE anstelle von MONGODB
%- kein traditionelles Relationales Schema
%- Mongodb hätte jedoch direkt JSON results
%- Für kleines Umfeld ist SQLITE auch akzeptabel
%- alternativen wären: mysql
%- nodejs hat aber auch ein npm repo für sqlite
% - Um die Daten Zentral auf dem Server verwalten zu können musste eine Datenbank eingerichtet werden
% - Hierbei bestand die Frage, ob klassische Relationale DB oder dokument-orientierte DB
% - dokument-orientiert vorteile wegen JSON strings, nachteile: keine Relationen, alles in Strings, starkes umdenken erforderlich für NUtzer mit Kenntnis über Relationale DBs
%- Relationale DB wird genutzt (SQLITE), damit lassen sich Zusammenhänge leicht deklarieren, SQLite ist zudem lightweight und wird für nicht ganz so aufwändige Schemata genutzt
% - zum Schema: (ER Diagramm hier einfügen)
%   * User Tabelle
%     zum Speichern der Nutzerdaten
%     auf typen eingehen (warum Name und Descr. nur 30 Zeichen, warumn PIN und PW 64char - SHA256 hex string)
%   * Room Tabelle
%     name und description (zur Kennzeichnung von Physikalischen Räumen)
%   * Roomusers Tabelle
%     Nutzer können sich in mehreren Räumen anmelden
%   * Board Tabelle
%     resolution und roomID
%     jedes Board hat eine andere Auflösung - um den Kontent auf jedem Board korrekt anzeigen zu können, muss die Auflösung des Boards ausgelesen werden, zudem hängt jedes Board nur vor einem Raum und kann dementsprechend auch nur einem Raum zugewiesen werden
%   * Content Tabelle
%     wenn ein Nutzer Kontent erzeugt oder ändert wird ein neuer Eintrag erzeugt, um jegliche Änderung später auswerten zu können
%     Dazu gehört wann die änderung statt fand, was der neue Content ist und was als Background URL eingestellt ist
%   * message Tabelle
%     jedes mal wenn ein Nutzer auf einem Board eine Nachricht für einen oder mehrere Nutzer erstellt wird ein neues Element angelegt
%     Zeit und INhalt der Nachricht werden hier gespeichert, die Relation mit USer wird über eine dritte Tabelle realisiert
%   * msgTo Tabelle
%     hier werden die PS von User und Message zusammengefasst. Zudem wird hier angegeben, ob der entsprechende Nutzer diese Nachricht schon gelesen hat und ein Token wird generiert, wodurch der Nutzer diese Nachricht direkt aufrufen kann, ohne sich vorher anmelden zu müssen
%   * status Tabelle
%     hier wird der Status der Nutzer gespeichert, jedes Mal wenn der Nutzer einen neuen Status angibt, wird ein neuer Eintrag erzeugt. Nur der neuste Status ist gültig
%     gespeichert wird die erstellzeit, endzeit, der statustext und der dazugehörige Nutzer
%   * feedback Tabelle
%     hier werden alle feedback drafts abgelegt mit timestamp





















\section{Umsetzung}\label{Umsetzung}
% hier kommt eine Überleitung vom Entwurf hin

% NodeJS und JS
%   * Express app für mvc policy
%   * banquo           -- dafür da umhtml seiten zu einem image zu rendern
%    body-parser       -- middleware für express zum parsen des bodys ??? was macht das ding??
%    canvas            -- teil von paperjs
%    cookie-parser     -- cookie tool
%    crypto-js         -- crypto library für passwort hashes
%    debug             -- debug tool
%    emailjs           -- tool zum senden von mails
%    express           -- mvc framework
%    express-session   -- session tool for express
%    jade              -- template engine
%    jquery            -- JS DOM manipulation tool
%    jquery-touchswipe -- small tool to enable a swipe gesture
%    moment            -- JS time tool
%    morgan            -- http request logger
%    nib               -- middleware for stylus
%    paper             -- canvas manipulation tool
%    serve-favicon     -- express enable favicon
%    sqlite3           -- database api
%    stylus            -- css generator
%    twitter           -- twitter api tool
%    uuid              -- session uuid generator
% - Frontend: HTML mit Javascript und JQuery zum Dom-manipulieren
%   * Webseite wird nur einmal geladen, um damit alles nötige zu holen
%   * Dynamischer Content wird per ajax vom Server geholt
%   * bei verbindungsabbrüchen werden bestimmte states gehalten und andere sind durch inconnectivität nicht möglich
%   
%
%Packages:
%- Express
%- SQLite
%  * warum SQLite anstelle von MongoDB (relational vs dokument-orientiert)
%- PaperJS
%- crypto-JS for SHA256 password/pin hashing
%- ....
%
%Server
%Struktur der Webseite
%Editor
% -> Was ist besser gegenüber den Funktionen, die er anfangs haben sollte?
% -> Privacy
% -> Nur als Framework vorhanden -> Interface musste selbst erstellt werden
% -> Voraussetzung: HTML5 Canvas Element
%Backend
%Design CSS
%Bootstrap
%Javascript Code??

% Emailtoken
% - Nutzer im Raum müssen in irgend einer Weise darüber informiert werden, dass sie eine Nachricht erhalten haben --> mail / app
% wenn eine Nachricht an einen Besitzer abgeschickt wird, wird ein Token generiert, der mit der Nachricht verbunden wird, dieser Token wird dann in der url in der benachrichtigungsmail mitgeschickt und ruft beim Aufruf der der url die Nachricht ab

% Sessions
% Ajax zur realisierung von CRUD

% - Überlegung zur Auslagerung des Admin Backends

% Sidebar Da manche Nutzer vergessen würden ihn wieder zu schließen, er sich nach einer bestimmten Zeit automatisch wieder schließen.










\section{Features}\label{Features}
Alle Features des Boards\\
\\
% Unterschied zu Hermes / NetBoards
% jeder user hat eigene Pinnwand weil tablet resolution nicht so groß und dadurch wenig platz, mach keinen sinn für alle nutzer im raum nur eine pinnwand zu bieten (vergleich NetBoards) - switch betweeen them
%so ein bischen gestalten, wie das how to pdf
%Editor:
%Drag and Drop Images - URL wird geholt und ein neues Image wird erzeugt
% imgUR API
%Pen
%text
%Stroke Size
%Color
%farbe von pen und text elementen ändern
%
%Auswahlwerkzeug:
%selektierung von einzelnen Objekten
%selektierung von mehreren objekten mit bounding box
%Popup
%löschen von markierten elementen
%Layering
%Kopieren
%Translation der Objekte in Bounding Box
%Scale der Objekte in Bounding Box
%Rotation der Objekte in der Bounding box
%Eraser Tool
%UNDO/REDO
%Image Upload
%Image Drag and Drop
%Gif Layer Support
%
%Twitter API für den letzten Tweet eines bestimmten Nutzers 
%
%Client Sessions
%mit npm plugin express-sessions serverseitig
%cookie ID client seitig
%caching of content for disconnects
%N/A marking of user image
%status set
%background layer
%nachrichten schreiben >> mail versenden mit unique token >> nachricht content direkt lesen mittels token
%  * nachricht an 1, 1+ oder alle im raum schicken
% feedback: hat einfach nur den editor

%Backend
% logs, user, room, board administration


% - Zudem sollen sie die möglichkeit bekommen sich als nicht anwesend markieren zu können, damit Gäste, die auf die Boards schauen schnell sehen, wer da ist und wer nicht
% - Nutzer im Raum, die gern Twitter benutzen sollen die öglichkeit bekommen ihren TwitterAccount anzugeben, damit ihr letzter tweet auf ihrer Pinnwand angezeigt werden kann
















\section{Probleme}\label{Probleme}
Die Probleme, auf die ich während der Arbeit gekommen bin\\
%Editor:\\
%- Gif Layer Hack\\
%- Scale Problem\\
%- Stroke Size Problem\\
%Problem: Desktop Version dimensions
%- die Auflösung auf dem Desktop ist größer als auf dem Tablet
%- content, der auf dem Desktop weiter rechts/weiter unten erstellt wird, verschwindet auf dem tablet :(
%- Lösungsansätze:
%  # Canvas resize auf größeren Auflösungen
%  # anzeige von linien, wie es auf dem tablet angezeigt wird
%Problem Header
%- durch horizontale ausrichtung der tablets ist der Platz des header zu groß und wird verschwendet
%- wenn nur userimage, username, status, description usw angezeigt werden muss
%- Lösung: absolutes header div, welches oben rechts in der ecke ist
%  # content hat dadurch tatsächlich die größe des tablets
%  # platz wird nicht so stark verschwendet
%  # "toter winkel" oben rechts in den raw datas der images
%- die ganze css datei muss angepasst werden, da positionen und größen relativ zum header gesetzt waren
%- random server deadlock --> restart script
%- Message Email mit image direkt in der NAchricht im HTML als <img> element ging nicht, da  cross origin resource sharing(CORS) nicht aktiviert ist (origin-clean flag false) deswegen geht die Funktion .toDataURL("image/png") nicht
%   * Zudem ist es schwer in der mail ein paperJS project in ein canvas einzubinden
%   * deswegen die Überlegung beim erstellen der message das canvas objekt direkt zu exportieren