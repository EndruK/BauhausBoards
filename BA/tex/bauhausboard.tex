\chapter{BauhausBoards}\label{BauhausBoards}
Das neue Projekt bekam den Namen ``BauhausBoards''.
In einer Entwurfsphase entschied ich, wie das System aussehen und welche Funktionen es bieten sollte. Dabei flossen die Ergebnisse der Vorstudie und anderer Projekte mit ein.
\\
Als Voraussetzung sollten als Anzeigegeräte für die Türschilder weiterhin Tablets genutzt werden.
Der Entwurf wurde darauf in ein Programm umgesetzt, wobei manche geplante Funktionen geändert, entfernt oder neue hinzugefügt wurden. An manchen Stellen der Umsetzung kam es auch zu Problemen, die es zu lösen galt.
% - Ergebnisse der Vorstudie sollten enbezogen werden
% - sollte weiterhin auf Tablets als Anzeigegerät laufen
% - das was im Entwurf geplant wurde musste umgesetzt werden
% - dadurch entstanden Features
% - Während der Umsetzung traten diverse Probleme auf










\section{Entwurf}\label{Entwurf}
\subsection{Systementwurf}\label{Systementwurf}
Die Planung des Systems begann damit, die Plattform des Systems auszuwählen. Es gab die Möglichkeit eine Android-Applikation zu erstellen, die auf jedem Tablet installiert werden müsste. Dabei gäb es jedoch das Problem, dass die Nutzer auch von unterwegs mit der Anwendung interagieren sollten, wofür ein eigenständiger Server für die Datenverwaltung notwendig gewesen wäre. Außerdem müsste durch die unterschiedlichen Tablet- und Smartphone-Betriebssysteme neben Android, wie Apple IOS oder Windows Mobile, die App für jede Architektur portiert werden.
\\
Deswegen fiel die Wahl auf eine Web-Applikation. Zum Einen, weil jedes Tablet, jedes Smartphone und jeder PC Webseiten darstellen kann und es nicht nötig ist, extra eine App auf den Geräten zu installieren.
\\ \todotext{darauf eingehen, dass NetBoards auch eine Web-Applikation benutzt hat?}\\
%Zudem setzte das NetBoards Projekt ebenfalls auf eine Web-Applikation
Ein zentraler Webserver generiert eine Webseite mit allen nötigen Frontend Funktionen, die von allen Geräten mit Web-Browser (Clients) angezeigt werden kann. Dadurch sollte sich der Programmieraufwand auf Server- und Client-Funktionen einschränken.
\\
Die Applikation sollte nicht bei jeder kleinsten Interaktion mit der Webseite diese neu laden müssen. Das hätte einen viel zu großen Overhead erzeugt, da bei jeder Kommunikation statische Daten übertragen worden wären.
Deswegen musste der Server nur beim ersten Aufruf das Grundgerüst der Webseite mit allen Client-Funktionen ausliefern. Ein Teil der Funktionen würde dann Daten nachladen oder an den Server schicken, wodurch ein dynamischer Inhalt erzeugt wird.
Dies sollte mit dem ``CRUD'' (Create, Read, Update and Delete) Prinzip realisiert werden.
Der Server wartet, nachdem er eine Seite ausgeliefert hat, auf spezifische Anfragen des Clients und liefert dementsprechend Daten aus (Read) oder ändert den Zustand der Daten (Create, Update und Delete). Zudem gewährleistet dieses Prinzip, dass bei Verbindungsabbrüchen die Seite auf dem Client weiter läuft und nur so lange keine Daten ändern oder nachladen kann, bis die Verbindung wieder aufgebaut wurde.
\\
Die anfallenden Daten des Systems mussten in irgend einer Form auf dem Server gespeichert werden. Die beste Methode dafür war die Nutzung einer Datenbank. Anders als bei NetBoards, wo alle Daten als JSON\footnote{\quelle{JSON ist ein, für Menschen leicht zu lesendes und Maschinen leicht zu parsendes, Datenaustauschformat}{json:website}}-Dateien auf dem Server gespeichert wurden, sah ich diese Methode als geeigneter an. Mit einer Datenbank war es möglich Relationen besser darzustellen, Konsistenz zu bewahren und Redundanz zu vermeiden. Zudem sind damit Daten zentralisiert zusammengefasst, wodurch eine bessere Suche nach bestimmten Daten möglich ist.
\\
Die Wahl des Datenbanksystems fiel auf ``SQLite''\cite{sqlite:website}, da es das am meisten verbreitete relationale Datenbanksystem der Welt ist. Es war einfach zu benutzen und hatte eine gute Dokumentation.
\\
Das Gerüst der Webseite sollte auf HTML basieren, wobei die hauptsächlichen Client-Funktionen üblicherweise in Javascript umgesetzt werden. Da die Clients viele Funktionen bieten sollten und der Server nur zum Ausliefern der Webseite und für den Datenaustausch dienen sollte, machte es Sinn für den Server ``Node.js'' zu verwenden. \quelle{Node.js ist serverseitiges Javascript basierend auf Google Chrome's V8 Javascript Engine}{nodejs:website}.
\\
\\
In der Abb. \ref{img:Systemaufbau} ist der Aufbau des Systems zusammengefasst. Auf dem Server befinden sich der Webserver und die Datenbank. Der Webserver stellt Anfragen an die Datenbank und erhält dafür entsprechende Ergebnisse zurückgeliefert.
\\
Wenn ein Client die Adresse des Servers aufruft generiert der Webserver die Webseite und sendet sie mit allen benötigten Funktionen an den Client. Solange die Seite nicht explizit neu geladen werden soll, kommuniziert der Client danach nur durch CRUD Interaktionen mit dem Server.
\\
\begin{figure}[h!]
  \centering
    \includegraphics[width=0.8\textwidth]{./img/Systemaufbau.png}
  \caption{Bauhausboards - Systemaufbau}
  \label{img:Systemaufbau}
\end{figure}
\\
Da die Nutzer die Möglichkeit bekommen sollten, individuellen Inhalt präsentieren zu können, musste ein geeigneter Editor programmiert werden.
Damit sollte es möglich sein, einfache Zeichnungen anzufertigen, Texte zu schreiben oder Bilder hochladen zu können.
Es war wichtig, dass der Editor die Funktionen eines Whiteboards in manchen Zügen übernehmen oder möglicherweise sogar verbessern konnte.
\\
Folgende Whiteboard-Funktionen musste der Editor daher abbilden:
\begin{itemize}
  \item Zeichnen mit verschiedenfarbigen Stiften
  \item Entfernen von Zeichnungen mit einem Schwamm
  \item Anbringung von Bildern oder Ausdrücken per Magnet
  \item Neuanordnung von aufgehängten Elementen
\end{itemize}
Als Grundlage für den Editor entschied ich mich für die Javascript Bibliothek ``Paper.js''\cite{paperjs:website}.
Es ist ein Open Source Framework für die Darstellung und Manipulation von Vektorgrafiken, welches auch die Grundlage des Editors aus dem NetBoards Projekt bildete\cite{wood:2014}.
\\
\\
Eine weitere wichtige Entscheidung war, dass nur die an den Boards registrierten Nutzer den dargestellten Inhalt ändern können sollten, da sich in der Vorstudie herausstellte, dass durch die Anonymität der Besucher es häufig zu unerwünschten Änderungen kam.
Dadurch sollte ein weiterer Sicherheitsaspekt geschaffen werden, da keine andere Person die Daten ändern kann außer derjenige, der sie erstellt hat.
\\
Den Besuchern sollte jedoch weiterhin die Möglichkeit geboten werden mit den registrierten Nutzern in Kontakt treten zu können. Dies konnte mit einer separaten Nachrichtenfunktion realisiert werden.











\subsection{Interface-Entwurf}\label{Interface-Entwurf}
\subsubsection{Hauptansicht}\label{Hauptansicht}
Da den Gästen in der Vorstudie nicht bewusst war, dass mehrere Personen auf dem Board registriert waren, was der Größe des Tablets zu verschulden war, musste der vorhandene Platz anders aufgeteilt werden. Das NetBoards System teilte den Bereich verschiedener Benutzer räumlich, indem es den verfügbaren Platz durch die Anzahl der registrierten Benutzer teilte.
Auf einem 10,1 Zoll großem Tablet macht dieser Ansatz jedoch wenig Sinn, da bei mehr als einem Benutzer der verfügbare Platz zu klein wäre\abb{img:aufteilungMainView}.
\begin{figure}[h!]
  \centering
    \includegraphics[width=0.68\textwidth]{./img/AufteilungMainView.png}
  \caption{Vergleich der Platzverteilung NetBoards - Bauhausboards}
  \label{img:aufteilungMainView}
\end{figure}
\\
Deswegen sollte jeder registrierte Nutzer die ganze Fläche zu Verfügung haben, wobei nach einer festgelegten Zeit die Sicht wechselt und die Daten des nächsten Nutzers anzeigt.
\\
Die Datenansicht sollte in zwei Schichten aufgeteilt werden. Zum einen eine Editor-Schicht für selbst gezeichnete Skizzen, Texte, Bilder und animierte Gifs, sowie eine Hintergrundschicht, in der die Nutzer eine Webseite anzeigen lassen können. Da NetBoards diese Funktion bereits bot und die Testnutzer in der Vorstudie diese ebenfalls nutzten entschied ich mich sie ebenfalls umzusetzen.
\\
Um auf der Webseite navigieren zu können musste es dafür ein Menü geben, die auf den Tablets nicht viel Platz wegnahm. Die beste Variante dafür war ein Sidebar, der standardmäßig eingeklappt war und sich per Klick oder Swipe-Geste öffnen ließ.
In diesem Menü sollten alle Navigationselemente zu untergebracht sein. 
\\
Um Informationen über die Nutzer anzeigen zu können wurde eine zusätzliche Fläche benötigt. Dafür sollte im oberen Bereich des Displays ein Teil nur für solche Informationen reserviert sein. In diesem Header konnte man das Profilbild, den Namen und eine Beschreibung des aktuell ausgewählten Nutzers darstellen.
In der Vorstudie wurde es sehr gut aufgenommen, dass einer der Nutzer seinen aktuellen Status angegeben hat. Deswegen sollte diese Funktion neben den Nutzerinformationen im Header zu finden sein.
\begin{figure}[h!]
  \centering
    \includegraphics[width=0.7\textwidth]{./img/MainViewAufbau.png}
  \caption{Aufbau der Hauptansicht}
  \label{img:mainView}
\end{figure}
\\
%Messages
Damit die Gäste mit den Besitzern in Kontakt treten können musste es eine Nachrichtenfunktion geben. Dabei sollten die Benutzer, die eine Nachricht erstellen wollen, einen oder mehrere Besitzer auswählen können. Wenn sie das getan haben, soll der Editor aktiviert werden und die Besucher können eine Zeichnung oder einen Text zeichnen. Die Besitzer müssen, nachdem die Nachricht abgeschickt wurde, darüber informiert werden, dass jemand ihnen etwas geschrieben hat.
% - QR-Code, um mit Smartphone einzuscannen -> möglichkeit per smartphone Nachrichten zu hinterlassen

\subsubsection{Benutzer-Backend}\label{Benutzer-Backend}
Die Besitzer der Boards sollten ihren öffentlichen Inhalt ändern, einen Status setzten und empfangene Nachrichten lesen können.
Dafür müssen sie sich vorher im Benutzer-Backend authentisieren.
\\
Das Backend soll den Nutzern die Möglichkeit bieten, ihre Nutzerdaten, wie das Profilbild, die Benutzerbeschreibung oder das Passwort ändern zu können.
\\
Um die angezeigten Daten der Hauptseite anzupassen, wird der selbe Editor verwendet, der auch bei der Erstellung von Besuchernachrichten zum Einsatz kommt.
\\
Für den Status sollen die Nutzer einen kurzen Text und den Endzeitpunkt festlegen, der dann auf der Hauptseite angezeigt wird.
\\
Außerdem mussten sie die Möglichkeit bekommen, erhaltenen Nachrichten einsehen zu können. Ungelesene Nachrichten sollten dabei besonders gekennzeichnet sein.\\
Die Änderung der Benutzerdaten sollten in einem gesonderten Einstellungsbereich möglich sein.
\\
Da das Benutzer-Backend auch vom aufgehängtem Display aus erreichbar sein soll, damit die Nutzer beim verlassen des Raumes schnell einen Status setzen können, mussten sie sich schnell authentisieren können. Deswegen entschied ich mich für zwei Authentisierungsmethoden. Ein vierstelliger Pin sollte zur schnellen Anmeldung in das Backend dienen. Die Benutzereinstellungen konnten dann nach einer klassischen Passwortauthentisierung vorgenommen werden.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.9\textwidth]{./img/LocationsFrontend.png}
  \caption{Bauhausboards - Interface Funktionen}
  \label{img:Interface}
\end{figure}

\subsubsection{Administrator-Backend}\label{Administrator-Backend}
Der Administrator der Boards muss die Funktionen bekommen, das System verwalten zu können. Das beinhaltet das erstellen, ändern und entfernen von Nutzern, sowie Board-Instanzen.
\\
Zudem soll er für Studienzwecke die Inhalte und Nachrichten der Benutzer einsehen können.b

\subsection{Datenbankentwurf}\label{Datenbankentwurf}
Durch die geplanten Funktionen mussten anfallende Daten in einer Datenbank gespeichert werden.
Es bestand die Möglichkeit eine dokumentenbasierte oder eine relationale Datenbank dafür zu nutzen.
Eine dokumentenbasierte Datenbank hätte den Vorteil gehabt, dass alle Anfragen eine JSON-Zeichenkette zurückgeben. JSON wird häufig in der Verbindung mit Javascript und dessen Serverkommunikation verwendet.
Relationale Datenbanken hingegen verwenden eine Tabellenstruktur für die Speicherung von Daten. Mit ihnen lassen sich Beziehungen zwischen den Daten einfacher darstellen.
\\
Für die Datenbank von Bauhausboards entschied ich mich für eine relationale Datenbank, da die Einarbeitungszeit, um mit dokumentenbasierten Datenbanken umgehen zu können, zu lang gedauert hätte.
\begin{figure}[h!]
  \centering
    \includegraphics[width=0.75\textwidth]{./img/ER01.png}
  \caption{Bauhausboards - Entity Relationship Diagramm}
  \label{img:ER01}
\end{figure}
\\
Der Datenbankentwurf beinhaltete 6 Objektklassen, dargestellt als Tabellen. Um alle Objekte eindeutig beschreiben zu können wurde in jeder Tabelle eine ID als Primärschlüssel\footnote{Ein Primärschlüssel ist ein Attribut zur eindeutigen Identifikation eines Datensatzes} hinzugefügt.
\\\todotext{soll ich bei den Attributen noch auf die Datentypen eingehen?}\\
\subsubsection{User Tabelle}\label{User Tabelle}
Die User-Tabelle ist die Haupttabelle und dient zur Speicherung von Nutzeraccounts. Ein Nutzer muss auf jeden Fall einen Namen, eine Emailadresse, ein Passwort und einen Pin haben.
Zusätzlich können die Nutzer auch ein Profilbild, eine eigene Beschreibung und, wenn erwünscht, ein Twitter-Account angegeben werden.
Wenn ein Benutzeraccount erstellt wird, soll das aktuelle Datum mitgespeichert werden.
\\
Ein Benutzer kann entweder in einem oder keinem Raum arbeiten. Er kann beliebig viele Status und Inhalte erzeugen und beliebig viele Nachrichten erhalten.
\subsubsection{Board Tabelle}\label{Board Tabelle}
Diese Tabelle ist die digitale Repräsentation von tatsächlich aufgehängten Displays. Da verschiedene Tablets eine unterschiedliche Auflösung haben können, musste diese in der Datenbank für jedes Board gespeichert werden. Ein Board kann entweder noch keinem oder genau einem Raum zugeordnet sein.
\subsubsection{Room Tabelle}\label{Room Tabelle}
In dieser Tabelle werden die möglichen Räume, vor denen Boards aufgehangen werden können registriert. Jeder Raum hat einen Namen und möglicherweise eine Beschreibung. Ein Raum kann entweder keinem oder mehreren Boards zugeordnet sein. Zudem können beliebig viele Personen in einem Raum arbeiten.
\subsubsection{Content Tabelle}\label{Content Tabelle}
Mit dieser Tabelle werden die Inhalte von den Nutzern gespeichert. Ein Inhalt besteht aus einem JSON-Objekt und einem Erstelldatum. Wenn für den Inhalt eine Hintergrundwebseite angegeben wurde, wird deren Adresse ebenfalls an dieser Stelle eingetragen. Jeder Inhalt hat genau einen Nutzer, der ihn erstellt hat.
\subsubsection{Status Tabelle}\label{Status Tabelle}
Die Status Tabelle dient zur Speicherung von Nutzerstatus. Jeder Nutzerstatus hat einen Statustext, ein Erstelldatum, einen Endzeitpunkt und genau einen Ersteller. 
\subsubsection{Message Tabelle}\label{Message Tabelle}
In der Message Tabelle werden Nachrichten abgelegt, die von Besuchern erstellt wurden. Eine Nachricht hat einen Nachrichteninhalt und ein Erstelldatum. Da die Nachricht an mehrere Besitzer adressiert sein kann, hat jede mindestens einen Empfänger.
\\
\\
Die Relationen zwischen User und Message, sowie zwischen User und Room müssen jeweils über eine dritte Tabelle dargestellt werden. In diesen Tabellen werden dann nur die Primärschlüssel der beiden beteiligten Objekte gespeichert.






















\section{Umsetzung}\label{Umsetzung}
\subsection{Funktionen}\label{Funktionen}
\todotext{vll ein treffenderer name als Funktionen? vllt Bibliotheken?}\\
% Ich muss hier nicht auf jede kleine lib eingehen -> nur auf die wichtigsten
% hier kommt eine Überleitung vom Entwurf hin
Nachdem das der Aufbau des Systems geplant war, mussten diese Pläne in ein lauffähiges Programm umgesetzt werden.
Um die Entwicklung mit Node.js zu vereinfachen wurde das Framework Express\cite{express:website} verwendet. Damit ließ sich eine einfache Webapplikation erstellen.
\\
Da die hauptsächlichen Funktionen auf den Clients ausgeführt werden sollten, mussten diese in Javascript geschrieben werden.
Am wichtigsten war, dass die Seite sich nicht neu lud, wenn man durch sie navigierte. Dies wurde mit jQuery\cite{jquery:website} realisiert. jQuery ist eine Bibliothek zur einfachen Manipulation der HTML-Struktur einer Webseite. Mit ihr war es einfach, die dargestellte Ansicht anzupassen.
\\
Der Kern der Clientfunktionen war der Editor zum Erzeugen von Nutzer-Inhalten und Besuchernachrichten. Da Paper.js nur ein Framework war, musste das Interface dafür von Grund auf implementiert werden.
Voraussetzungen für Paper.js war, dass die Webseite für dem neuesten HTML5 Standard entwickelt wurde, da diese Version ein neues Canvas-Element bot, mit dem Grafiken gezeichnet werden konnten.
\\
Falls an einer Stelle der Seite Daten vom Server benötigt wurden oder Daten auf dem Server geändert werden mussten, wurde dies mit Ajax-Anfragen durchgeführt. Ajax (Asynchronous Javascript and XML) ist eine Funktion für asynchronen Datenaustausch zwischen einem Client und einem Server.
Während ein Client auf die Ajax-Antwort des Servers wartet können weiterhin andere Funktionen ausgeführt werden.
\\
% jquery touchswipe -> swipe tool für die swipe geste
Um die Sidebar auf Tablets leichter öffnen zu können nutzte ich TouchSwipe\cite{touchswipe:website}. Mit dieser Bibliothek konnten Swipe-Gesten zum aufruf von Funktionen genutzt werden.
\\
% cryptoJS hash lib für passwort hashes
Die Passwörter und Pins durften nicht im Klartext gespeichert werden.
Dafür wurde die crypto-js\cite{cryptojs:website} Bibliothek verwendet, um die sicherheitsrelevanten Daten mit SHA256\footnote{SHA256 (Secure Hash Algorithm 256) ist eine Krypto-Hashfunktion} zu hashen.
\\
% emailJS = mail tool
Damit die Besitzer der Boards benachrichtigt werden, wenn Gäste ihnen Nachrichten hinterlassen, musste der Server Emails verschicken können.
Die Bibliothek emailjs\cite{emailjs:website} brachte diese Funktion mit. Zusätzlich benötigte der Server zum Verschicken einer Mail einen eigenen Mailserver oder wenigstens einen Account an einem anderen Mailserver.
In den Benachrichtigungsmails sollte ein Link mit einem Token\footnote{Ein Token ist ein Attribut zur Freigabe von Daten zwischen Parteien(Wer den Token hat, kann die Datei lesen)} zu der jeweiligen erhaltenen Nachricht im System sein. Der Token wurde mit crypto-js beim Abspeichern der Nachricht auf dem Server erzeugt. Wenn der Empfänger auf den Link klickt, wird der Token geprüft und die Entsprechende Nachricht angezeigt ohne, dass sich der dieser authentisieren muss.
\\
Die Farbgestaltung der Seite wurde schlicht gehalten und orientierte sich an den Hausfarben der Medienfakultät der BUW.\\\todotext{mehr zur css gestaltung?}
\\
\\
Während der Umsetzung änderte sich die Entscheidung, alle Funktionen in einer einzigen Seite anzubieten, vom geplanten Konzept.\\
Im Konzept war ursprünglich geplant, dass der Administrator normal über die Seite die Administratorfunktionen ausführen kann. Da diese Funktionen aber rein funktional waren und nicht auf den Boards gebraucht wurden, ergab es mehr Sinn diese gesondert in eine zusätzlichen Webseite auszulagern.

% Editor Features
%Drag and Drop Images - URL wird geholt und ein neues Image wird erzeugt
%Pen
%text
%Stroke Size
%Color
%farbe von pen und text elementen ändern
%Auswahlwerkzeug:
%selektierung von einzelnen Objekten
%selektierung von mehreren objekten mit bounding box
%Popup
%löschen von markierten elementen
%Layering
%Kopieren
%Translation der Objekte in Bounding Box
%Scale der Objekte in Bounding Box
%Rotation der Objekte in der Bounding box
%Eraser Tool
%UNDO/REDO
%Gif Layer Support

% Background Feature (einfach nur eine hintergrundlayer ohne pointer events)

%caching of content for disconnects
%status set
%N/A marking of user image
% - Zudem sollen sie die möglichkeit bekommen sich als nicht anwesend markieren zu können, damit Gäste, die auf die Boards schauen schnell sehen, wer da ist und wer nicht

%Twitter API für den letzten Tweet eines bestimmten Nutzers 
% - Nutzer im Raum, die gern Twitter benutzen sollen die öglichkeit bekommen ihren TwitterAccount anzugeben, damit ihr letzter tweet auf ihrer Pinnwand angezeigt werden kann






\subsection{Features}\label{Features}
\todotext{das kann zu Funktionen, daher ist das Kapitel überflüssig}
% Unterschied zu Hermes / NetBoards
% jeder user hat eigene Pinnwand weil tablet resolution nicht so groß und dadurch wenig platz, mach keinen sinn für alle nutzer im raum nur eine pinnwand zu bieten (vergleich NetBoards) - switch betweeen them
% größeres Display als bei Hermes, kleineres als bei NetBoards
% Ähnlicher Editor auf selber Basis wie bei NetBoards
% Nutzer bekommen Mails, wie bei Hermes??

%background layer wie bei NetBoards

%nachrichten schreiben >> mail versenden mit unique token >> nachricht content direkt lesen mittels token
%  * nachricht an 1, 1+ oder alle im raum schicken
%  * direkte nachrichten gab es nur bei Hermes, bei NetBoards konnte man nur die Pinnwand direkt manipulieren
% feedback: hat einfach nur den editor















\subsection{Probleme}\label{Probleme}
Die Probleme, auf die ich während der Arbeit gekommen bin\\
%Editor:\\
%- Gif Layer Hack\\
%- Scale Problem\\
%- Stroke Size Problem\\
%Problem: Desktop Version dimensions
%- die Auflösung auf dem Desktop ist größer als auf dem Tablet
%- content, der auf dem Desktop weiter rechts/weiter unten erstellt wird, verschwindet auf dem tablet :(
%- Lösungsansätze:
%  # Canvas resize auf größeren Auflösungen
%  # anzeige von linien, wie es auf dem tablet angezeigt wird
%Problem Header
%- durch horizontale ausrichtung der tablets ist der Platz des header zu groß und wird verschwendet
%- wenn nur userimage, username, status, description usw angezeigt werden muss
%- Lösung: absolutes header div, welches oben rechts in der ecke ist
%  # content hat dadurch tatsächlich die größe des tablets
%  # platz wird nicht so stark verschwendet
%  # "toter winkel" oben rechts in den raw datas der images
%- die ganze css datei muss angepasst werden, da positionen und größen relativ zum header gesetzt waren
%- random server deadlock --> restart script
%- Message Email mit image direkt in der NAchricht im HTML als <img> element ging nicht, da  cross origin resource sharing(CORS) nicht aktiviert ist (origin-clean flag false) deswegen geht die Funktion .toDataURL("image/png") nicht
%   * Zudem ist es schwer in der mail ein paperJS project in ein canvas einzubinden
%   * deswegen die Überlegung beim erstellen der message das canvas objekt direkt zu exportieren

% gif:
% canvas element konnte nativ keine gifs anzeigen
%  -> lösung: gif layer
% wenn mehrere gifs des gleichen names: nur ein gif wird ausgeführt, die anderen sind statisch